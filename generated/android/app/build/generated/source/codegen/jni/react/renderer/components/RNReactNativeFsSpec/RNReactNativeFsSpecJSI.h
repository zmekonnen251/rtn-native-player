/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeReactNativeFsDownloadResultT

template <typename P0, typename P1, typename P2>
struct NativeReactNativeFsDownloadResultT {
  P0 jobId;
  P1 statusCode;
  P2 bytesWritten;
  bool operator==(const NativeReactNativeFsDownloadResultT &other) const {
    return jobId == other.jobId && statusCode == other.statusCode && bytesWritten == other.bytesWritten;
  }
};

template <typename T>
struct NativeReactNativeFsDownloadResultTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.jobId)>(rt, value.getProperty(rt, "jobId"), jsInvoker),
      bridging::fromJs<decltype(types.statusCode)>(rt, value.getProperty(rt, "statusCode"), jsInvoker),
      bridging::fromJs<decltype(types.bytesWritten)>(rt, value.getProperty(rt, "bytesWritten"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double jobIdToJs(jsi::Runtime &rt, decltype(types.jobId) value) {
    return bridging::toJs(rt, value);
  }

  static double statusCodeToJs(jsi::Runtime &rt, decltype(types.statusCode) value) {
    return bridging::toJs(rt, value);
  }

  static double bytesWrittenToJs(jsi::Runtime &rt, decltype(types.bytesWritten) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "jobId", bridging::toJs(rt, value.jobId, jsInvoker));
    result.setProperty(rt, "statusCode", bridging::toJs(rt, value.statusCode, jsInvoker));
    result.setProperty(rt, "bytesWritten", bridging::toJs(rt, value.bytesWritten, jsInvoker));
    return result;
  }
};



#pragma mark - NativeReactNativeFsFSInfoResultT

template <typename P0, typename P1, typename P2, typename P3>
struct NativeReactNativeFsFSInfoResultT {
  P0 totalSpace;
  P1 totalSpaceEx;
  P2 freeSpace;
  P3 freeSpaceEx;
  bool operator==(const NativeReactNativeFsFSInfoResultT &other) const {
    return totalSpace == other.totalSpace && totalSpaceEx == other.totalSpaceEx && freeSpace == other.freeSpace && freeSpaceEx == other.freeSpaceEx;
  }
};

template <typename T>
struct NativeReactNativeFsFSInfoResultTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.totalSpace)>(rt, value.getProperty(rt, "totalSpace"), jsInvoker),
      bridging::fromJs<decltype(types.totalSpaceEx)>(rt, value.getProperty(rt, "totalSpaceEx"), jsInvoker),
      bridging::fromJs<decltype(types.freeSpace)>(rt, value.getProperty(rt, "freeSpace"), jsInvoker),
      bridging::fromJs<decltype(types.freeSpaceEx)>(rt, value.getProperty(rt, "freeSpaceEx"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double totalSpaceToJs(jsi::Runtime &rt, decltype(types.totalSpace) value) {
    return bridging::toJs(rt, value);
  }

  static double totalSpaceExToJs(jsi::Runtime &rt, decltype(types.totalSpaceEx) value) {
    return bridging::toJs(rt, value);
  }

  static double freeSpaceToJs(jsi::Runtime &rt, decltype(types.freeSpace) value) {
    return bridging::toJs(rt, value);
  }

  static double freeSpaceExToJs(jsi::Runtime &rt, decltype(types.freeSpaceEx) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "totalSpace", bridging::toJs(rt, value.totalSpace, jsInvoker));
    result.setProperty(rt, "totalSpaceEx", bridging::toJs(rt, value.totalSpaceEx, jsInvoker));
    result.setProperty(rt, "freeSpace", bridging::toJs(rt, value.freeSpace, jsInvoker));
    result.setProperty(rt, "freeSpaceEx", bridging::toJs(rt, value.freeSpaceEx, jsInvoker));
    return result;
  }
};



#pragma mark - NativeReactNativeFsFileOptionsT

template <typename P0>
struct NativeReactNativeFsFileOptionsT {
  P0 NSFileProtectionKey;
  bool operator==(const NativeReactNativeFsFileOptionsT &other) const {
    return NSFileProtectionKey == other.NSFileProtectionKey;
  }
};

template <typename T>
struct NativeReactNativeFsFileOptionsTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.NSFileProtectionKey)>(rt, value.getProperty(rt, "NSFileProtectionKey"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String NSFileProtectionKeyToJs(jsi::Runtime &rt, decltype(types.NSFileProtectionKey) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.NSFileProtectionKey) {
      result.setProperty(rt, "NSFileProtectionKey", bridging::toJs(rt, value.NSFileProtectionKey.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeReactNativeFsMkdirOptionsT

template <typename P0, typename P1>
struct NativeReactNativeFsMkdirOptionsT {
  P0 NSURLIsExcludedFromBackupKey;
  P1 NSFileProtectionKey;
  bool operator==(const NativeReactNativeFsMkdirOptionsT &other) const {
    return NSURLIsExcludedFromBackupKey == other.NSURLIsExcludedFromBackupKey && NSFileProtectionKey == other.NSFileProtectionKey;
  }
};

template <typename T>
struct NativeReactNativeFsMkdirOptionsTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.NSURLIsExcludedFromBackupKey)>(rt, value.getProperty(rt, "NSURLIsExcludedFromBackupKey"), jsInvoker),
      bridging::fromJs<decltype(types.NSFileProtectionKey)>(rt, value.getProperty(rt, "NSFileProtectionKey"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool NSURLIsExcludedFromBackupKeyToJs(jsi::Runtime &rt, decltype(types.NSURLIsExcludedFromBackupKey) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String NSFileProtectionKeyToJs(jsi::Runtime &rt, decltype(types.NSFileProtectionKey) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.NSURLIsExcludedFromBackupKey) {
      result.setProperty(rt, "NSURLIsExcludedFromBackupKey", bridging::toJs(rt, value.NSURLIsExcludedFromBackupKey.value(), jsInvoker));
    }
    if (value.NSFileProtectionKey) {
      result.setProperty(rt, "NSFileProtectionKey", bridging::toJs(rt, value.NSFileProtectionKey.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeReactNativeFsNativeDownloadFileOptionsT

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14>
struct NativeReactNativeFsNativeDownloadFileOptionsT {
  P0 jobId;
  P1 fromUrl;
  P2 toFile;
  P3 background;
  P4 backgroundTimeout;
  P5 cacheable;
  P6 connectionTimeout;
  P7 discretionary;
  P8 headers;
  P9 progressDivider;
  P10 progressInterval;
  P11 readTimeout;
  P12 hasBeginCallback;
  P13 hasProgressCallback;
  P14 hasResumableCallback;
  bool operator==(const NativeReactNativeFsNativeDownloadFileOptionsT &other) const {
    return jobId == other.jobId && fromUrl == other.fromUrl && toFile == other.toFile && background == other.background && backgroundTimeout == other.backgroundTimeout && cacheable == other.cacheable && connectionTimeout == other.connectionTimeout && discretionary == other.discretionary && headers == other.headers && progressDivider == other.progressDivider && progressInterval == other.progressInterval && readTimeout == other.readTimeout && hasBeginCallback == other.hasBeginCallback && hasProgressCallback == other.hasProgressCallback && hasResumableCallback == other.hasResumableCallback;
  }
};

template <typename T>
struct NativeReactNativeFsNativeDownloadFileOptionsTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.jobId)>(rt, value.getProperty(rt, "jobId"), jsInvoker),
      bridging::fromJs<decltype(types.fromUrl)>(rt, value.getProperty(rt, "fromUrl"), jsInvoker),
      bridging::fromJs<decltype(types.toFile)>(rt, value.getProperty(rt, "toFile"), jsInvoker),
      bridging::fromJs<decltype(types.background)>(rt, value.getProperty(rt, "background"), jsInvoker),
      bridging::fromJs<decltype(types.backgroundTimeout)>(rt, value.getProperty(rt, "backgroundTimeout"), jsInvoker),
      bridging::fromJs<decltype(types.cacheable)>(rt, value.getProperty(rt, "cacheable"), jsInvoker),
      bridging::fromJs<decltype(types.connectionTimeout)>(rt, value.getProperty(rt, "connectionTimeout"), jsInvoker),
      bridging::fromJs<decltype(types.discretionary)>(rt, value.getProperty(rt, "discretionary"), jsInvoker),
      bridging::fromJs<decltype(types.headers)>(rt, value.getProperty(rt, "headers"), jsInvoker),
      bridging::fromJs<decltype(types.progressDivider)>(rt, value.getProperty(rt, "progressDivider"), jsInvoker),
      bridging::fromJs<decltype(types.progressInterval)>(rt, value.getProperty(rt, "progressInterval"), jsInvoker),
      bridging::fromJs<decltype(types.readTimeout)>(rt, value.getProperty(rt, "readTimeout"), jsInvoker),
      bridging::fromJs<decltype(types.hasBeginCallback)>(rt, value.getProperty(rt, "hasBeginCallback"), jsInvoker),
      bridging::fromJs<decltype(types.hasProgressCallback)>(rt, value.getProperty(rt, "hasProgressCallback"), jsInvoker),
      bridging::fromJs<decltype(types.hasResumableCallback)>(rt, value.getProperty(rt, "hasResumableCallback"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double jobIdToJs(jsi::Runtime &rt, decltype(types.jobId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String fromUrlToJs(jsi::Runtime &rt, decltype(types.fromUrl) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String toFileToJs(jsi::Runtime &rt, decltype(types.toFile) value) {
    return bridging::toJs(rt, value);
  }

  static bool backgroundToJs(jsi::Runtime &rt, decltype(types.background) value) {
    return bridging::toJs(rt, value);
  }

  static double backgroundTimeoutToJs(jsi::Runtime &rt, decltype(types.backgroundTimeout) value) {
    return bridging::toJs(rt, value);
  }

  static bool cacheableToJs(jsi::Runtime &rt, decltype(types.cacheable) value) {
    return bridging::toJs(rt, value);
  }

  static double connectionTimeoutToJs(jsi::Runtime &rt, decltype(types.connectionTimeout) value) {
    return bridging::toJs(rt, value);
  }

  static bool discretionaryToJs(jsi::Runtime &rt, decltype(types.discretionary) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object headersToJs(jsi::Runtime &rt, decltype(types.headers) value) {
    return bridging::toJs(rt, value);
  }

  static double progressDividerToJs(jsi::Runtime &rt, decltype(types.progressDivider) value) {
    return bridging::toJs(rt, value);
  }

  static double progressIntervalToJs(jsi::Runtime &rt, decltype(types.progressInterval) value) {
    return bridging::toJs(rt, value);
  }

  static double readTimeoutToJs(jsi::Runtime &rt, decltype(types.readTimeout) value) {
    return bridging::toJs(rt, value);
  }

  static bool hasBeginCallbackToJs(jsi::Runtime &rt, decltype(types.hasBeginCallback) value) {
    return bridging::toJs(rt, value);
  }

  static bool hasProgressCallbackToJs(jsi::Runtime &rt, decltype(types.hasProgressCallback) value) {
    return bridging::toJs(rt, value);
  }

  static bool hasResumableCallbackToJs(jsi::Runtime &rt, decltype(types.hasResumableCallback) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "jobId", bridging::toJs(rt, value.jobId, jsInvoker));
    result.setProperty(rt, "fromUrl", bridging::toJs(rt, value.fromUrl, jsInvoker));
    result.setProperty(rt, "toFile", bridging::toJs(rt, value.toFile, jsInvoker));
    result.setProperty(rt, "background", bridging::toJs(rt, value.background, jsInvoker));
    result.setProperty(rt, "backgroundTimeout", bridging::toJs(rt, value.backgroundTimeout, jsInvoker));
    result.setProperty(rt, "cacheable", bridging::toJs(rt, value.cacheable, jsInvoker));
    result.setProperty(rt, "connectionTimeout", bridging::toJs(rt, value.connectionTimeout, jsInvoker));
    result.setProperty(rt, "discretionary", bridging::toJs(rt, value.discretionary, jsInvoker));
    result.setProperty(rt, "headers", bridging::toJs(rt, value.headers, jsInvoker));
    result.setProperty(rt, "progressDivider", bridging::toJs(rt, value.progressDivider, jsInvoker));
    result.setProperty(rt, "progressInterval", bridging::toJs(rt, value.progressInterval, jsInvoker));
    result.setProperty(rt, "readTimeout", bridging::toJs(rt, value.readTimeout, jsInvoker));
    result.setProperty(rt, "hasBeginCallback", bridging::toJs(rt, value.hasBeginCallback, jsInvoker));
    result.setProperty(rt, "hasProgressCallback", bridging::toJs(rt, value.hasProgressCallback, jsInvoker));
    result.setProperty(rt, "hasResumableCallback", bridging::toJs(rt, value.hasResumableCallback, jsInvoker));
    return result;
  }
};



#pragma mark - NativeReactNativeFsNativeReadDirResItemT

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeReactNativeFsNativeReadDirResItemT {
  P0 ctime;
  P1 mtime;
  P2 name;
  P3 path;
  P4 size;
  P5 type;
  bool operator==(const NativeReactNativeFsNativeReadDirResItemT &other) const {
    return ctime == other.ctime && mtime == other.mtime && name == other.name && path == other.path && size == other.size && type == other.type;
  }
};

template <typename T>
struct NativeReactNativeFsNativeReadDirResItemTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.ctime)>(rt, value.getProperty(rt, "ctime"), jsInvoker),
      bridging::fromJs<decltype(types.mtime)>(rt, value.getProperty(rt, "mtime"), jsInvoker),
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<decltype(types.path)>(rt, value.getProperty(rt, "path"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double ctimeToJs(jsi::Runtime &rt, decltype(types.ctime) value) {
    return bridging::toJs(rt, value);
  }

  static double mtimeToJs(jsi::Runtime &rt, decltype(types.mtime) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String pathToJs(jsi::Runtime &rt, decltype(types.path) value) {
    return bridging::toJs(rt, value);
  }

  static double sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "ctime", bridging::toJs(rt, value.ctime, jsInvoker));
    result.setProperty(rt, "mtime", bridging::toJs(rt, value.mtime, jsInvoker));
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "path", bridging::toJs(rt, value.path, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
    return result;
  }
};



#pragma mark - NativeReactNativeFsNativeStatResultT

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeReactNativeFsNativeStatResultT {
  P0 ctime;
  P1 mtime;
  P2 size;
  P3 type;
  P4 mode;
  P5 originalFilepath;
  bool operator==(const NativeReactNativeFsNativeStatResultT &other) const {
    return ctime == other.ctime && mtime == other.mtime && size == other.size && type == other.type && mode == other.mode && originalFilepath == other.originalFilepath;
  }
};

template <typename T>
struct NativeReactNativeFsNativeStatResultTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.ctime)>(rt, value.getProperty(rt, "ctime"), jsInvoker),
      bridging::fromJs<decltype(types.mtime)>(rt, value.getProperty(rt, "mtime"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<decltype(types.mode)>(rt, value.getProperty(rt, "mode"), jsInvoker),
      bridging::fromJs<decltype(types.originalFilepath)>(rt, value.getProperty(rt, "originalFilepath"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double ctimeToJs(jsi::Runtime &rt, decltype(types.ctime) value) {
    return bridging::toJs(rt, value);
  }

  static double mtimeToJs(jsi::Runtime &rt, decltype(types.mtime) value) {
    return bridging::toJs(rt, value);
  }

  static double sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }

  static double modeToJs(jsi::Runtime &rt, decltype(types.mode) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String originalFilepathToJs(jsi::Runtime &rt, decltype(types.originalFilepath) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "ctime", bridging::toJs(rt, value.ctime, jsInvoker));
    result.setProperty(rt, "mtime", bridging::toJs(rt, value.mtime, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
    result.setProperty(rt, "mode", bridging::toJs(rt, value.mode, jsInvoker));
    result.setProperty(rt, "originalFilepath", bridging::toJs(rt, value.originalFilepath, jsInvoker));
    return result;
  }
};



#pragma mark - NativeReactNativeFsNativeUploadFileOptionsT

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct NativeReactNativeFsNativeUploadFileOptionsT {
  P0 jobId;
  P1 toUrl;
  P2 binaryStreamOnly;
  P3 files;
  P4 headers;
  P5 fields;
  P6 method;
  P7 hasBeginCallback;
  P8 hasProgressCallback;
  bool operator==(const NativeReactNativeFsNativeUploadFileOptionsT &other) const {
    return jobId == other.jobId && toUrl == other.toUrl && binaryStreamOnly == other.binaryStreamOnly && files == other.files && headers == other.headers && fields == other.fields && method == other.method && hasBeginCallback == other.hasBeginCallback && hasProgressCallback == other.hasProgressCallback;
  }
};

template <typename T>
struct NativeReactNativeFsNativeUploadFileOptionsTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.jobId)>(rt, value.getProperty(rt, "jobId"), jsInvoker),
      bridging::fromJs<decltype(types.toUrl)>(rt, value.getProperty(rt, "toUrl"), jsInvoker),
      bridging::fromJs<decltype(types.binaryStreamOnly)>(rt, value.getProperty(rt, "binaryStreamOnly"), jsInvoker),
      bridging::fromJs<decltype(types.files)>(rt, value.getProperty(rt, "files"), jsInvoker),
      bridging::fromJs<decltype(types.headers)>(rt, value.getProperty(rt, "headers"), jsInvoker),
      bridging::fromJs<decltype(types.fields)>(rt, value.getProperty(rt, "fields"), jsInvoker),
      bridging::fromJs<decltype(types.method)>(rt, value.getProperty(rt, "method"), jsInvoker),
      bridging::fromJs<decltype(types.hasBeginCallback)>(rt, value.getProperty(rt, "hasBeginCallback"), jsInvoker),
      bridging::fromJs<decltype(types.hasProgressCallback)>(rt, value.getProperty(rt, "hasProgressCallback"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double jobIdToJs(jsi::Runtime &rt, decltype(types.jobId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String toUrlToJs(jsi::Runtime &rt, decltype(types.toUrl) value) {
    return bridging::toJs(rt, value);
  }

  static bool binaryStreamOnlyToJs(jsi::Runtime &rt, decltype(types.binaryStreamOnly) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array filesToJs(jsi::Runtime &rt, decltype(types.files) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object headersToJs(jsi::Runtime &rt, decltype(types.headers) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object fieldsToJs(jsi::Runtime &rt, decltype(types.fields) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String methodToJs(jsi::Runtime &rt, decltype(types.method) value) {
    return bridging::toJs(rt, value);
  }

  static bool hasBeginCallbackToJs(jsi::Runtime &rt, decltype(types.hasBeginCallback) value) {
    return bridging::toJs(rt, value);
  }

  static bool hasProgressCallbackToJs(jsi::Runtime &rt, decltype(types.hasProgressCallback) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "jobId", bridging::toJs(rt, value.jobId, jsInvoker));
    result.setProperty(rt, "toUrl", bridging::toJs(rt, value.toUrl, jsInvoker));
    if (value.binaryStreamOnly) {
      result.setProperty(rt, "binaryStreamOnly", bridging::toJs(rt, value.binaryStreamOnly.value(), jsInvoker));
    }
    result.setProperty(rt, "files", bridging::toJs(rt, value.files, jsInvoker));
    if (value.headers) {
      result.setProperty(rt, "headers", bridging::toJs(rt, value.headers.value(), jsInvoker));
    }
    if (value.fields) {
      result.setProperty(rt, "fields", bridging::toJs(rt, value.fields.value(), jsInvoker));
    }
    if (value.method) {
      result.setProperty(rt, "method", bridging::toJs(rt, value.method.value(), jsInvoker));
    }
    result.setProperty(rt, "hasBeginCallback", bridging::toJs(rt, value.hasBeginCallback, jsInvoker));
    result.setProperty(rt, "hasProgressCallback", bridging::toJs(rt, value.hasProgressCallback, jsInvoker));
    return result;
  }
};



#pragma mark - NativeReactNativeFsPickFileOptionsT

template <typename P0>
struct NativeReactNativeFsPickFileOptionsT {
  P0 mimeTypes;
  bool operator==(const NativeReactNativeFsPickFileOptionsT &other) const {
    return mimeTypes == other.mimeTypes;
  }
};

template <typename T>
struct NativeReactNativeFsPickFileOptionsTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.mimeTypes)>(rt, value.getProperty(rt, "mimeTypes"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array mimeTypesToJs(jsi::Runtime &rt, decltype(types.mimeTypes) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "mimeTypes", bridging::toJs(rt, value.mimeTypes, jsInvoker));
    return result;
  }
};



#pragma mark - NativeReactNativeFsTouchOptions

template <typename P0, typename P1>
struct NativeReactNativeFsTouchOptions {
  P0 ctime;
  P1 mtime;
  bool operator==(const NativeReactNativeFsTouchOptions &other) const {
    return ctime == other.ctime && mtime == other.mtime;
  }
};

template <typename T>
struct NativeReactNativeFsTouchOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.ctime)>(rt, value.getProperty(rt, "ctime"), jsInvoker),
      bridging::fromJs<decltype(types.mtime)>(rt, value.getProperty(rt, "mtime"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double ctimeToJs(jsi::Runtime &rt, decltype(types.ctime) value) {
    return bridging::toJs(rt, value);
  }

  static double mtimeToJs(jsi::Runtime &rt, decltype(types.mtime) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.ctime) {
      result.setProperty(rt, "ctime", bridging::toJs(rt, value.ctime.value(), jsInvoker));
    }
    if (value.mtime) {
      result.setProperty(rt, "mtime", bridging::toJs(rt, value.mtime.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeReactNativeFsUploadResultT

template <typename P0, typename P1, typename P2, typename P3>
struct NativeReactNativeFsUploadResultT {
  P0 jobId;
  P1 statusCode;
  P2 headers;
  P3 body;
  bool operator==(const NativeReactNativeFsUploadResultT &other) const {
    return jobId == other.jobId && statusCode == other.statusCode && headers == other.headers && body == other.body;
  }
};

template <typename T>
struct NativeReactNativeFsUploadResultTBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.jobId)>(rt, value.getProperty(rt, "jobId"), jsInvoker),
      bridging::fromJs<decltype(types.statusCode)>(rt, value.getProperty(rt, "statusCode"), jsInvoker),
      bridging::fromJs<decltype(types.headers)>(rt, value.getProperty(rt, "headers"), jsInvoker),
      bridging::fromJs<decltype(types.body)>(rt, value.getProperty(rt, "body"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double jobIdToJs(jsi::Runtime &rt, decltype(types.jobId) value) {
    return bridging::toJs(rt, value);
  }

  static double statusCodeToJs(jsi::Runtime &rt, decltype(types.statusCode) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object headersToJs(jsi::Runtime &rt, decltype(types.headers) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String bodyToJs(jsi::Runtime &rt, decltype(types.body) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "jobId", bridging::toJs(rt, value.jobId, jsInvoker));
    result.setProperty(rt, "statusCode", bridging::toJs(rt, value.statusCode, jsInvoker));
    result.setProperty(rt, "headers", bridging::toJs(rt, value.headers, jsInvoker));
    result.setProperty(rt, "body", bridging::toJs(rt, value.body, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeReactNativeFsCxxSpecJSI : public TurboModule {
protected:
  NativeReactNativeFsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String event) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual jsi::Value appendFile(jsi::Runtime &rt, jsi::String path, jsi::String b64) = 0;
  virtual jsi::Value copyFile(jsi::Runtime &rt, jsi::String from, jsi::String into, jsi::Object options) = 0;
  virtual jsi::Value downloadFile(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value exists(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value getFSInfo(jsi::Runtime &rt) = 0;
  virtual jsi::Value hash(jsi::Runtime &rt, jsi::String path, jsi::String algorithm) = 0;
  virtual jsi::Value mkdir(jsi::Runtime &rt, jsi::String path, jsi::Object options) = 0;
  virtual jsi::Value moveFile(jsi::Runtime &rt, jsi::String from, jsi::String into, jsi::Object options) = 0;
  virtual jsi::Value pickFile(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value read(jsi::Runtime &rt, jsi::String path, double length, double position) = 0;
  virtual jsi::Value readFile(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value readDir(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value stat(jsi::Runtime &rt, jsi::String path) = 0;
  virtual void stopDownload(jsi::Runtime &rt, double jobId) = 0;
  virtual void stopUpload(jsi::Runtime &rt, double jobId) = 0;
  virtual jsi::Value touch(jsi::Runtime &rt, jsi::String path, jsi::Object options) = 0;
  virtual jsi::Value unlink(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value uploadFiles(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value write(jsi::Runtime &rt, jsi::String path, jsi::String b64, double position) = 0;
  virtual jsi::Value writeFile(jsi::Runtime &rt, jsi::String path, jsi::String b64, jsi::Object options) = 0;
  virtual jsi::Value copyFileAssets(jsi::Runtime &rt, jsi::String from, jsi::String into) = 0;
  virtual jsi::Value copyFileRes(jsi::Runtime &rt, jsi::String from, jsi::String into) = 0;
  virtual jsi::Value existsAssets(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value existsRes(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value getAllExternalFilesDirs(jsi::Runtime &rt) = 0;
  virtual jsi::Value readFileAssets(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value readFileRes(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value readDirAssets(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value scanFile(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value setReadable(jsi::Runtime &rt, jsi::String filepath, bool readable, bool ownerOnly) = 0;
  virtual jsi::Value copyAssetsFileIOS(jsi::Runtime &rt, jsi::String imageUri, jsi::String destPath, double width, double height, double scale, double compression, jsi::String resizeMode) = 0;
  virtual jsi::Value copyAssetsVideoIOS(jsi::Runtime &rt, jsi::String imageUri, jsi::String destPath) = 0;
  virtual void completeHandlerIOS(jsi::Runtime &rt, double jobId) = 0;
  virtual jsi::Value isResumable(jsi::Runtime &rt, double jobId) = 0;
  virtual jsi::Value pathForBundle(jsi::Runtime &rt, jsi::String bundle) = 0;
  virtual jsi::Value pathForGroup(jsi::Runtime &rt, jsi::String group) = 0;
  virtual void resumeDownload(jsi::Runtime &rt, double jobId) = 0;
  virtual jsi::Value copyFolder(jsi::Runtime &rt, jsi::String from, jsi::String into) = 0;

};

template <typename T>
class JSI_EXPORT NativeReactNativeFsCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ReactNativeFs";

protected:
  NativeReactNativeFsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeReactNativeFsCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeReactNativeFsCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeReactNativeFsCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void addListener(jsi::Runtime &rt, jsi::String event) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(event));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    jsi::Value appendFile(jsi::Runtime &rt, jsi::String path, jsi::String b64) override {
      static_assert(
          bridging::getParameterCount(&T::appendFile) == 3,
          "Expected appendFile(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::appendFile, jsInvoker_, instance_, std::move(path), std::move(b64));
    }
    jsi::Value copyFile(jsi::Runtime &rt, jsi::String from, jsi::String into, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::copyFile) == 4,
          "Expected copyFile(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::copyFile, jsInvoker_, instance_, std::move(from), std::move(into), std::move(options));
    }
    jsi::Value downloadFile(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::downloadFile) == 2,
          "Expected downloadFile(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::downloadFile, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value exists(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::exists) == 2,
          "Expected exists(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::exists, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value getFSInfo(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getFSInfo) == 1,
          "Expected getFSInfo(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getFSInfo, jsInvoker_, instance_);
    }
    jsi::Value hash(jsi::Runtime &rt, jsi::String path, jsi::String algorithm) override {
      static_assert(
          bridging::getParameterCount(&T::hash) == 3,
          "Expected hash(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::hash, jsInvoker_, instance_, std::move(path), std::move(algorithm));
    }
    jsi::Value mkdir(jsi::Runtime &rt, jsi::String path, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::mkdir) == 3,
          "Expected mkdir(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::mkdir, jsInvoker_, instance_, std::move(path), std::move(options));
    }
    jsi::Value moveFile(jsi::Runtime &rt, jsi::String from, jsi::String into, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::moveFile) == 4,
          "Expected moveFile(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::moveFile, jsInvoker_, instance_, std::move(from), std::move(into), std::move(options));
    }
    jsi::Value pickFile(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::pickFile) == 2,
          "Expected pickFile(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::pickFile, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value read(jsi::Runtime &rt, jsi::String path, double length, double position) override {
      static_assert(
          bridging::getParameterCount(&T::read) == 4,
          "Expected read(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::read, jsInvoker_, instance_, std::move(path), std::move(length), std::move(position));
    }
    jsi::Value readFile(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::readFile) == 2,
          "Expected readFile(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readFile, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value readDir(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::readDir) == 2,
          "Expected readDir(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readDir, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value stat(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::stat) == 2,
          "Expected stat(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::stat, jsInvoker_, instance_, std::move(path));
    }
    void stopDownload(jsi::Runtime &rt, double jobId) override {
      static_assert(
          bridging::getParameterCount(&T::stopDownload) == 2,
          "Expected stopDownload(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopDownload, jsInvoker_, instance_, std::move(jobId));
    }
    void stopUpload(jsi::Runtime &rt, double jobId) override {
      static_assert(
          bridging::getParameterCount(&T::stopUpload) == 2,
          "Expected stopUpload(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopUpload, jsInvoker_, instance_, std::move(jobId));
    }
    jsi::Value touch(jsi::Runtime &rt, jsi::String path, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::touch) == 3,
          "Expected touch(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::touch, jsInvoker_, instance_, std::move(path), std::move(options));
    }
    jsi::Value unlink(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::unlink) == 2,
          "Expected unlink(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::unlink, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value uploadFiles(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::uploadFiles) == 2,
          "Expected uploadFiles(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::uploadFiles, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value write(jsi::Runtime &rt, jsi::String path, jsi::String b64, double position) override {
      static_assert(
          bridging::getParameterCount(&T::write) == 4,
          "Expected write(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::write, jsInvoker_, instance_, std::move(path), std::move(b64), std::move(position));
    }
    jsi::Value writeFile(jsi::Runtime &rt, jsi::String path, jsi::String b64, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::writeFile) == 4,
          "Expected writeFile(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::writeFile, jsInvoker_, instance_, std::move(path), std::move(b64), std::move(options));
    }
    jsi::Value copyFileAssets(jsi::Runtime &rt, jsi::String from, jsi::String into) override {
      static_assert(
          bridging::getParameterCount(&T::copyFileAssets) == 3,
          "Expected copyFileAssets(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::copyFileAssets, jsInvoker_, instance_, std::move(from), std::move(into));
    }
    jsi::Value copyFileRes(jsi::Runtime &rt, jsi::String from, jsi::String into) override {
      static_assert(
          bridging::getParameterCount(&T::copyFileRes) == 3,
          "Expected copyFileRes(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::copyFileRes, jsInvoker_, instance_, std::move(from), std::move(into));
    }
    jsi::Value existsAssets(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::existsAssets) == 2,
          "Expected existsAssets(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::existsAssets, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value existsRes(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::existsRes) == 2,
          "Expected existsRes(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::existsRes, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value getAllExternalFilesDirs(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getAllExternalFilesDirs) == 1,
          "Expected getAllExternalFilesDirs(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getAllExternalFilesDirs, jsInvoker_, instance_);
    }
    jsi::Value readFileAssets(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::readFileAssets) == 2,
          "Expected readFileAssets(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readFileAssets, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value readFileRes(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::readFileRes) == 2,
          "Expected readFileRes(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readFileRes, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value readDirAssets(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::readDirAssets) == 2,
          "Expected readDirAssets(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readDirAssets, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value scanFile(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::scanFile) == 2,
          "Expected scanFile(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::scanFile, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value setReadable(jsi::Runtime &rt, jsi::String filepath, bool readable, bool ownerOnly) override {
      static_assert(
          bridging::getParameterCount(&T::setReadable) == 4,
          "Expected setReadable(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setReadable, jsInvoker_, instance_, std::move(filepath), std::move(readable), std::move(ownerOnly));
    }
    jsi::Value copyAssetsFileIOS(jsi::Runtime &rt, jsi::String imageUri, jsi::String destPath, double width, double height, double scale, double compression, jsi::String resizeMode) override {
      static_assert(
          bridging::getParameterCount(&T::copyAssetsFileIOS) == 8,
          "Expected copyAssetsFileIOS(...) to have 8 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::copyAssetsFileIOS, jsInvoker_, instance_, std::move(imageUri), std::move(destPath), std::move(width), std::move(height), std::move(scale), std::move(compression), std::move(resizeMode));
    }
    jsi::Value copyAssetsVideoIOS(jsi::Runtime &rt, jsi::String imageUri, jsi::String destPath) override {
      static_assert(
          bridging::getParameterCount(&T::copyAssetsVideoIOS) == 3,
          "Expected copyAssetsVideoIOS(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::copyAssetsVideoIOS, jsInvoker_, instance_, std::move(imageUri), std::move(destPath));
    }
    void completeHandlerIOS(jsi::Runtime &rt, double jobId) override {
      static_assert(
          bridging::getParameterCount(&T::completeHandlerIOS) == 2,
          "Expected completeHandlerIOS(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::completeHandlerIOS, jsInvoker_, instance_, std::move(jobId));
    }
    jsi::Value isResumable(jsi::Runtime &rt, double jobId) override {
      static_assert(
          bridging::getParameterCount(&T::isResumable) == 2,
          "Expected isResumable(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isResumable, jsInvoker_, instance_, std::move(jobId));
    }
    jsi::Value pathForBundle(jsi::Runtime &rt, jsi::String bundle) override {
      static_assert(
          bridging::getParameterCount(&T::pathForBundle) == 2,
          "Expected pathForBundle(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::pathForBundle, jsInvoker_, instance_, std::move(bundle));
    }
    jsi::Value pathForGroup(jsi::Runtime &rt, jsi::String group) override {
      static_assert(
          bridging::getParameterCount(&T::pathForGroup) == 2,
          "Expected pathForGroup(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::pathForGroup, jsInvoker_, instance_, std::move(group));
    }
    void resumeDownload(jsi::Runtime &rt, double jobId) override {
      static_assert(
          bridging::getParameterCount(&T::resumeDownload) == 2,
          "Expected resumeDownload(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::resumeDownload, jsInvoker_, instance_, std::move(jobId));
    }
    jsi::Value copyFolder(jsi::Runtime &rt, jsi::String from, jsi::String into) override {
      static_assert(
          bridging::getParameterCount(&T::copyFolder) == 3,
          "Expected copyFolder(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::copyFolder, jsInvoker_, instance_, std::move(from), std::move(into));
    }

  private:
    friend class NativeReactNativeFsCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
